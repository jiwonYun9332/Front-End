### 0604

#### 메모리 동적 할당

```
int main()
{
    int* pData = new int;

    int* pNewData = new int(10);

    *pData = 5;
    std::cout << *pData << std::endl;
    std::cout << *pNewData << std::endl;

    delete pData;
    delete pNewData;

    return 0;
}
```

**배열 형태로 동적 생성한 것은 반드시 배열 형태를 통해 삭제**

```
int main()
{

    int* arr = new int[5];
    for (int i = 0; i<5; ++i)
        arr[i] = (i + 1) * 10;

    for (int i = 0; i < 5; ++i)
        cout << arr[i] << endl;

    delete[] arr;

    return 0;
}
```

**new 연산자는 객체의 생성자를 호출하고, delete 연산자는 객체의 소멸자를 호출한다.**

#### 참조자 형식

reference 형식은 C에는 없는 형식으로 포인터와 구조적으로 비슷하다.

또한 다음과 같이 선언과 동시에 반드시 초기화해야 한다.

형식 &이름 = 원본;

예) int &rData = a;

```
int main()
{

    int nData = 10;

    int &ref = nData;

    ref = 20;
    cout << nData << endl;

    int *pnData = &nData;
    *pnData = 30;
    cout << nData << endl;

    return 0;
}
```

함수를 호출할 때 매개변수로 주소를 전달하는 기법을 `Call By Reference`이라 한다. 여기서의 Reference는 주소를 의미한다.

#### r-vaule reference

r-value란 대입 연산자의 두 피연산자 중 오른쪽에 위치한 연산자를 말하는 것으로, 일반적인 변수와 상수 모두 해당될 수 있다.

#### 범위 기반 for문

range-based

for(auto 요소변수 : 배열이름)

  반복구문;

auto는 **배열 요소 개수에 맞춰 자동으로 결정**된다.

```
int main()
{

    int aList[5] = { 10, 20, 30, 40, 50 };

    for (int i = 0; i < 5; ++i)
        aList[i] = 20;

    cout << endl;

    for (auto n : aList)
        n = 10;

    cout << endl;

    for (auto& n : aList)
    {
        n = 10;
        cout << n << ' ';
    }

    cout << endl;

    return 0;
}
```






















